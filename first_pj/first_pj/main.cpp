#include<iostream>
using namespace std;

class A {
public:
	static int i;//函数里有静态本地变量，这个变量实际位置在全局，写在class里面的东西都是声明
public:
	A() { i = 0; }	//初始化列表只能对非静态的成员做初始化
	void print() {
		cout << i << endl;
	}
	void set(int ii) {
		i = ii;
	}

	//静态的函数只能访问静态的成员变量
	static void say(int ii) {
		cout << i << "  " << ii << endl;
	}
};

//int A::i;	//声明中出现全局变量，那就一定要在cpp放这个变量（定义）
//static int A::i;//错，这表明这个静态变量只能在这个cpp中被访问，但是其实他是一个类的静态变量，类出现的时候，这个静态变量也会跟住出现
int A::i = 20;//可以
//静态的成员变量，在建立对象之前，就可以访问

int main() {
	A a, b;

	a.set(10);
	b.print();//因为i只有一个，所以b输出的就是被a改过的那个

	cout << A::i << endl;//不牵扯具体的对象
	a.say(0);
	A::say(0);

	return 0;
}

//static在c的含义：1）持久存储；2）访问性受到局限
//static的本地变量就是全局变量
//static在函数内部，那么这个变量相当于全局变量，但是只能在这个函数内部被访问

//void f() {
//	static x my_x(10, 20);	//存储是全局的，但是在第一次进函数的时候被初始化
//	不是在对象里面设置变量表明是否被初始化
//	如果一个对象是静态的，那么C++保证这个对象的构造是只发生一次的
//	有个伴随变量来记录是否已经被构造
//	...
//}

//全局变量的构造函数的运行，是在main之前。程序结束的时候，对应的析构函数会执行
//多个全局变量的初始化先后，是无法保证的
//当全局变量之间初始化相互依赖时，需要放到一个地方去